! -*- coding: utf-8; mode: f90 -*-
!-------------------------------------------------------------------------------------
! Copyright (c) 2000-2016 Gtool Development Group. All rights reserved.
!-------------------------------------------------------------------------------------
! ** Important**
!
! This file is generated from <%= __FILE__%> by ERB included Ruby <%=RUBY_VERSION %>.
! Please do not edit this file directly. @see "<%= __FILE__%>"
!-------------------------------------------------------------------------------------
!
!++
!= ポインタ配列への数値データの入力
!
! Authors::   Yasuhiro MORIKAWA, Eizi TOYODA
! Version::   $Id: gtvargetpointernum.rb2f90,v 1.5 2009-05-25 09:55:58 morikawa Exp $
! Tag Name::  $Name:  $
! Copyright:: Copyright (C) GFD Dennou Club, 2000-2005. All rights reserved.
! License::   See COPYRIGHT[link:../../COPYRIGHT]
!
! 以下のサブルーチン、関数は gtdata_generic から gtdata_generic#Get
! として提供されます。

  !
                                          !
  !== ポインタ配列への数値データの入力
  !
  ! 変数 *var* から *value* に数値データが入力されます。
  ! *value* はポインタ配列であり、数値データのサイズに合わせた
  ! 配列サイズが自動的に割り付けられます。
  ! *Get* は複数のサブルーチンの総称名であり、
  ! 1 〜 7 次元のポインタを与えることが可能です。
  ! また *value* に固定長配列を与えることが可能な手続きもあります。
  ! 下記を参照してください。
  !
  ! *value* が既に割り付けられており、且つ入力する数値データと配列
  ! サイズが異なる場合、エラー (コード dc_error#GT_EBADALLOCATESIZE)
  ! を生じます。原則的には *value* を空状態にして与えることを
  ! 推奨します。不定状態で与えることは予期せぬ動作を招く可能性が
  ! あるため禁止します。
  !
  ! 数値データ入力や上記の割り付けの際にエラーが生じた場合、メッセージ
  ! を出力してプログラムは強制終了します。*err* を与えてある場合には
  ! の引数に .true. が返り、プログラムは終了しません。
  !
  ! 入力しようとするデータの型が引数の型と異なる場合、データは引数の
  ! 型に変換されます。 この変換は netCDF の機能を用いています。
  ! 詳しくは {netCDF 日本語版マニュアル}[link:../xref.htm#label-10]
  ! の 3.3 型変換 を参照してください。
  !
  !
  ! This subroutine returns multi-dimensional data to argument "value".
  ! You need to provide GT_VARIABLE variable to argument "var".
  ! If you provide logical argument "err", .true. is returned
  ! instead of abort with messages when error is occurred.

% ["Double", "Real", "Int"].each do |type|
%   (1..7).each do |num|
%     array = Array.new(num, ':')
%     str = Array.new
subroutine GTVarGetPointer<%=type%><%=num%>(var, value, err)
  use gtdata_types,          only: GT_VARIABLE
  use gtdata_generic,        only: Get_Slice, GTVarGet<%=type%>
  use gtdata_internal_map,   only: map_set_rank
  use gtdata_netcdf_generic, only: Get
  use gtdata_netcdf_types,   only: GD_NC_VARIABLE
  use dc_types,              only: STRING<%=', DP' if type == 'Double'%><%=', SP' if type == 'Real'%>
  use dc_trace,              only: DbgMessage
  use dc_error,              only: StoreError, DC_NOERR, &
    & GT_EBADALLOCATESIZE, GT_ENOMOREDIMS, GT_ERANKMISMATCH
  use dc_string,             only: toChar
  implicit none
  type(GT_VARIABLE), intent(in):: var
%   case type when 'Double'
  real(DP), pointer :: value<%="(#{array.join(',')})"%> !(out)
  real(DP), allocatable :: array1dim_tmp(:)
%   when 'Real'
  real(SP), pointer :: value<%="(#{array.join(',')})"%> !(out)
  real(SP), allocatable :: array1dim_tmp(:)
%   when 'Int'
  integer, pointer :: value<%="(#{array.join(',')})"%> !(out)
  integer, allocatable :: array1dim_tmp(:)
%   end
  logical, intent(out), optional  :: err
  integer                         :: stat, n(<%=num%>), cause_i, data_rank
  logical                         :: invalid_check(<%=num%>)
  character(STRING)               :: cause_c
  character(*), parameter :: subname = 'GTVarGetPointer<%=type%><%=num%>'
  continue
  cause_i = 0
  cause_c = ''
  n(<%=num%>) = -1
  stat = DC_NOERR
  call map_set_rank(var, <%=num%>, stat)
  if (stat /= DC_NOERR) goto 999
%     (1..num).each do |n|
  call Get_Slice(var, dimord=<%=n%>, count=n(<%=n%>), count_compact=.false.)
%     end
%     if num == 1
  if (n(1) < 0) then
    ! count_compact ではないので、ゼロ次元化していると n = -1 となる
    n(1) = 1
  endif
%     end
  call DbgMessage('n(:)=%*d', i=n, n=(/size(n)/))
  invalid_check = n > 0
  if (.not. all(invalid_check)) then
    stat = GT_ERANKMISMATCH
    data_rank = count(invalid_check)
    cause_c = trim(toChar(data_rank)) // ' and <%=num%>'
    goto 999
  end if
  ! value が allocate されていなければ allocate する.
  ! value が既に allocate されていてサイズが取得するデータと同じで
  ! あればそのまま取得.
  ! value が allocate されていてサイズが異なる場合はエラー.
  if ( associated(value) ) then
    if ( &
%     (1..num).each do |n|
      & .not. size(value,<%=n%>) == n(<%=n%>) .or. &
%     end
      & .false.                             ) then
      stat = GT_EBADALLOCATESIZE
      if (stat /= DC_NOERR) goto 999
    else
      call DbgMessage('@ value is already allocated')
    endif
  else
    call DbgMessage('@ allocate value')
    allocate( value (&
%     (1..num).each do |n| str[n-1] = n == num ? "n(#{n})": "n(#{n})," end
      & <%= str.join("  &\n      & ") %>)  &
      &  )
  endif
  if (allocated(array1dim_tmp)) then
    deallocate(array1dim_tmp)
  end if
  allocate(array1dim_tmp(product(n)))
  call GTVarGet<%=type%>(var, array1dim_tmp, product(n), err)
  !    call DbgMessage('max=%f min=%f', d=(/maxval(value), minval(value)/))
%     if num == 1
  value = array1dim_tmp
%   else
  value = reshape(array1dim_tmp, n)
%     end
999 continue
  call StoreError(stat, subname, err, cause_i=cause_i, cause_c=cause_c)
end subroutine GTVarGetPointer<%=type%><%=num%>

%   end
% end
