! -*- coding: utf-8; mode: f90 -*-
!-------------------------------------------------------------------------------------
! Copyright (c) 2000-2016 Gtool Development Group. All rights reserved.
!-------------------------------------------------------------------------------------
! ** Important**
!
! This file is generated from <%= __FILE__%> by ERB included Ruby <%=RUBY_VERSION %>.
! Please do not edit this file directly. @see "<%= __FILE__%>"
!-------------------------------------------------------------------------------------
!
!== 変数への数値データの出力
!
! 変数 *var* へ数値データ *value* が出力されます。
! *nvalue* には配列長を代入する必要があります。
!
! 数値データ出力の際にエラーが生じた場合、メッセージを出力
! してプログラムは強制終了します。*err* を与えてある場合には
! の引数に .true. が返り、プログラムは終了しません。
!
! 出力しようとするデータの型が *var* の型と異なる場合、データは *var* の
! 型に変換されます。 この変換は netCDF の機能を用いています。
! 詳しくは {netCDF 日本語版マニュアル}[link:../xref.htm#label-10]
! の 3.3 型変換 を参照してください。
!
! *Get* は複数のサブルーチンの総称名であり、
! *value* に多次元配列を与えることも可能です。上記の
! サブルーチンを参照してください。
!
% ["Double", "Real", "Int", "Char"].each do |type|
subroutine GTVarPut<%=type %>(var, value, nvalue, err)
  use gtdata_types, only: GT_VARIABLE
  use gtdata_internal_map, only: &
    & var_class, &
    & vtb_class_netcdf, &
    & map_to_internal_specs
  use gtdata_netcdf_generic,  only: put
  use gtdata_netcdf_types, only: GD_NC_VARIABLE
  use dc_error,    only: StoreError, GT_EFAKE
  ! use dc_trace,    only: BeginSub, EndSub
%   case type when 'Double'
  use dc_types,    only: DP
%   when 'Real'
  use dc_types,    only: SP
%   end
  implicit none
  type(GT_VARIABLE), intent(in)            :: var
  integer,           intent(in)            :: nvalue
%   case type when 'Double'
  real(DP),          intent(in)            :: value(nvalue)
%   when 'Real'
  real(SP),          intent(in)            :: value(nvalue)
%   when 'Int'
  integer,           intent(in)            :: value(nvalue)
%   when 'Char'
  character(*),      intent(in)            :: value(nvalue)
%   end
  logical,           intent(out), optional :: err
  ! Variables for Intenal work
  integer:: class, cid, stat, ndims
  integer, pointer:: specs(:, :)
  character(len = *), parameter:: subname = "GTVarPut<%=type%>"
  continue
  call var_class(var, class, cid)
  call map_to_internal_specs(var, specs, ndims)
  if (class == vtb_class_netcdf) then
    call put(GD_NC_VARIABLE(cid), start=specs(:, 1), count=specs(:, 2), &
      & stride=specs(:, 3), imap=specs(:, 4), value=value, &
      & siz=nvalue, iostat=stat)
  else
    stat = gt_efake
  endif
  call StoreError(stat, subname, err=err)
  deallocate(specs)
end subroutine GTVarPut<%= type%>

% end

% ["Double", "Real", "Int"].each do |type|
%   (1..7).each do |num|
%   array = Array.new(num, ':')
subroutine GTVarPut<%=type%><%=num%>(var, value, err)
  use gtdata_types,   only: GT_VARIABLE
  use gtdata_generic, only: Put, GTVarPut<%=type%>
%     case type when 'Double'
  use dc_types,       only: DP
  real(DP), intent(in) :: value<%="(#{array.join(',')})" unless num==0%>
%     when 'Real'
  use dc_types,       only: SP
  real(SP), intent(in) :: value<%="(#{array.join(',')})" unless num==0%>
%     when 'Int'
  integer,  intent(in) :: value<%="(#{array.join(',')})" unless num==0%>
%     end
  type(GT_VARIABLE), intent(inout):: var
  logical  ,intent(out), optional:: err
  continue
  call GTVarPut<%=type%>(var, value, size(value), err)
end subroutine GTVarPut<%=type%><%=num%>

%   end
% end
