! -*- coding: utf-8; mode: f90 -*-
!-------------------------------------------------------------------------------------
! Copyright (c) 2000-2016 Gtool Development Group. All rights reserved.
!-------------------------------------------------------------------------------------
! ** Important**
!
! This file is generated from <%= __FILE__%> by ERB included Ruby <%=RUBY_VERSION %>.
! Please do not edit this file directly. @see "<%= __FILE__%>"
!-------------------------------------------------------------------------------------
!
!
!= gtool4 netCDF データの入力
!= Input gtool4 netCDF data
!
! Authors::   Yasuhiro MORIKAWA
! Version::   $Id: historyget.rb2f90,v 1.3 2009-07-04 05:04:42 morikawa Exp $
! Tag Name::  $Name:  $
! Copyright:: Copyright (C) GFD Dennou Club, 2006. All rights reserved.
! License::   See COPYRIGHT[link:../../../COPYRIGHT]
!
! 以下のサブルーチン, 関数は gtool_history から gtool_history_generic#HistoryGet
! もしくは gtool_history_generic#HistoryGetPointer として提供されます.
!
! Following subroutines and functions are provided as
! gtool_history_generic#HistoryGet or gtool_history_generic#HistoryGetPointer from
! gtool_history.
!
  !
  ! <b>Note that Japanese and English are described in parallel.</b>
  !
                                            !
  ! netCDF データを入力します. gtool4 netCDF 規約に基づくデータを想定
  ! していますが, 大抵の netCDF データの入力は可能であると期待されます.
  !
  ! デフォルトでは, ファイル内の最新データ, すなわちデータを
  ! 時刻最大で切り出したものを入力します. 別の時刻または
  ! 別の次元で切り出したデータを
  ! 入力したい場合には, 下記の *time* オプションもしくは
  ! *range* オプションを利用してください.
  !
  ! *file* にファイル名を, *varname* に変数名を与えます.
  ! *array* にはファイルから入力されたデータが返ります.
  ! ポインタの配列へデータを入力を行う場合は,
  ! HistoryGetPointer を利用してください.
  !
  ! ある時刻のデータを明示したい場合には, その時刻を
  ! *time* に与えます.
  ! 整数型, 単精度実数型, 倍精度実数型の数値を与えることが可能です.
  !
  ! *range* には gtool4 のコンマ記法
  ! ({gtool4 netCDF 規約}[link:../xref.htm#label-6] の「5.4 コンマ記法」参照)
  ! を与えることで, 任意の次元で入力データを切り出すことが可能です.
  ! *range* に空文字を与えた場合は切り出しを行いません.
  !
  ! *HistoryGet* は複数のサブルーチンの総称名です. *array* には
  ! 0 〜 7 次元の整数型, 単精度実数型,
  ! 倍精度実数型の配列を与えることが可能です.
  !
  ! デフォルトでは, データの入力時にどのファイルのどの変数が
  ! どの次元で切り出されて入力されたのかを表示します.
  ! メッセージ出力が不要な場合は *quiet* に .true. を与えてください.
  !
  ! Input netCDF data. NetCDF data with gtool4 conventions is assumed,
  ! but most netCDF data is expected to be input.
  !
  ! Give filename to *file*, variable name to *varname*.
  ! Input data is returned to *array*.
  ! If you want to use pointer array, use "HistoryGetPointer".
  !
  ! By default, recent data, that is to say, data clipped with
  ! maximum time is input. In order to input data clipped with
  ! other time or other dimension,
  ! use *time* option or *range* option as follows.
  !
  ! In order to get data at certain time, specify the time to *time*.
  ! Type is integer or single precision real or double precision.
  !
  ! Give gtool4 comma-graphy
  ! (See "5.4 gtool4 comma-graphy" in {gtool4 netCDF Convention}[link:../xref.htm#label-6])
  ! to *range*, then input data can be clipped by an arbitrary dimension.
  ! If null character is given to *range*, data is not clipped.
  !
  ! *HistoryGet* is generic name of multiple subroutines.
  ! Integer, single precision real, and double precision real
  ! 0 -- 7 rank array can be given to *array*.
  !
  ! By default, when data is input, filename and variable name and
  ! clipping information is printed.
  ! The message is suppressed when .true. is given to *quiet*
  !

% ["Double", "Real", "Int"].each do |type|
%   (0..7).each do |num|
%     array = Array.new(num, ':')
%     str = Array.new
subroutine HistoryGet<%=type%><%=num%>(file, varname, array, range, &
  & quiet, flag_mpi_split, returned_time, flag_time_exist, err)
  use gtdata_types, only: GT_VARIABLE
  use gtdata_generic, only: Open, Inquire, Close, Get
  use dc_string, only: toChar, Split, JoinChar, StoA
  use dc_url, only: GT_ATMARK, GT_COMMA, GT_EQUAL, UrlSplit, UrlMerge
  use dc_present, only: present_select, present_and_not_empty, present_and_true
  use dc_regex, only: match
  use dc_types, only: STRING, DP<%=', SP' if type == 'Real' %>
  use dc_message, only: MessageNotify
  use dc_trace, only: DbgMessage
  use dc_error, only: StoreError, DC_NOERR, GT_ENOTURL, GT_ERANKMISMATCH, &
    & GT_EARGSIZEMISMATCH
#ifdef LIB_MPI
  ! MPI ライブラリ
  ! MPI library
  use mpi
#endif
  implicit none
  character(*), intent(in):: file
  character(*), intent(in):: varname
  character(*), intent(in), optional:: range
  logical,  intent(in),  optional:: quiet
  logical,  intent(in),  optional:: flag_mpi_split
  real(DP), intent(out), optional:: returned_time ! データの時刻
  logical,  intent(out), optional:: flag_time_exist
  logical,  intent(out), optional:: err
%     case type when 'Double'
  real(DP), intent(out) :: array<%="(#{array.join(',')})" unless num == 0%>
  real(DP)<%=', allocatable ' unless num == 0%> :: array_tmp<%= num == 0 ? "(1)":"(:)"%>
%     when 'Real'
  real(SP), intent(out) :: array<%="(#{array.join(',')})" unless num == 0%>
  real(SP)<%=', allocatable ' unless num == 0%> :: array_tmp<%= num == 0 ? "(1)":"(:)"%>
%     when 'Int'
  integer, intent(out) :: array<%="(#{array.join(',')})" unless num == 0%>
  integer<%=', allocatable ' unless num == 0%> :: array_tmp<%= num == 0 ? "(1)":"(:)"%>
%     end
%     unless num == 0
  integer:: array_allsize
  integer:: array_shape(<%=num%>), data_shape(<%=num%>), array_shape_check(<%=num%>)
  integer:: allcount
  integer:: i, sd
  logical:: inq_err
%     end
  type(GT_VARIABLE):: var
  character(STRING):: file_work, url, actual_url
  integer:: rank, alldims, array_rank
  integer:: domain
  character(STRING):: tname
  integer:: stat
  character(STRING):: cause_c
  character(*), parameter :: subname = "HistoryGet<%=type%><%=num%>"
  interface
    subroutine lookup_growable_url(file, varname, url, range, flag_time_exist, time_name, err)
      character(*), intent(in):: file
      character(*), intent(in):: varname
      character(*), intent(out):: url
      character(*), intent(in), optional:: range
      logical, intent(out), optional:: flag_time_exist
      character(*), intent(out), optional:: time_name
      logical, intent(out), optional:: err
    end subroutine lookup_growable_url
  end interface
  interface
    subroutine actual_iorange_dump(url, actual_url, returned_time, time_name, err)
      use dc_types, only: DP
      character(*), intent(in) :: url                ! 変数 URL
      character(*), intent(out), optional :: actual_url
      ! 正確な入出力範囲指定
      real(DP), intent(out), optional:: returned_time    ! データの時刻
      character(*), intent(in), optional:: time_name ! 時刻次元の名称
      logical, intent(out), optional :: err          ! エラーのフラグ
    end subroutine actual_iorange_dump
  end interface
  interface
    function file_rename_mpi( file ) result(result)
      use dc_types, only: STRING
      character(*), intent(in):: file
      character(STRING):: result
    end function file_rename_mpi
  end interface
  continue
  cause_c = ''
  stat = DC_NOERR
  file_work = file
%     unless num == 0
  array_shape = shape( array )
  array_allsize = size( array )
%     end
  ! ファイル名の変更 (MPI 用)
  ! Change filename (for MPI)
  !
  if ( present_and_true( flag_mpi_split ) ) &
    & file_work = file_rename_mpi( file_work )
  ! 最新時刻の URL 取得
  ! Get URL of latest time
  !
  call lookup_growable_url(file_work, varname, url, range, &
    & flag_time_exist = flag_time_exist, time_name = tname, err = err)
  if ( present_and_true(err) ) then
    stat = GT_ENOTURL
    cause_c = url
    goto 999
  end if
  ! ファイルオープン
  ! File open
  call Open( var, url, err = err )
  if ( present_and_true(err) ) then
    stat = GT_ENOTURL
    cause_c = url
    goto 999
  end if
  !-------------------------------------------------------------------
  !  配列形状のチェック
  !  Check array shape
  !-------------------------------------------------------------------
  ! 入力ファイル中のデータの次元数
  ! Get size of dimesions in data of an input file
  !
  call Inquire( var = var, &           ! (in)
    & rank = rank, alldims = alldims ) ! (out)
  ! 引数の次元数のチェック (縮退されている場合には減らす)
  ! Check size of dimensions of an argument (If any dimension degenerated, size of dimensions is decreased)
  array_rank = <%=num%>
%     unless num == 0
%       (1..num).each do |n|
  if ( size( array, <%=n%> ) == 1 ) array_rank = array_rank - 1
%       end
%     end
  ! 次元数の比較
  ! Compare sizes of dimensions
  !
  if ( .not. <%=num%> == rank .and. .not. array_rank == rank ) then
    if ( .not. present_and_true(quiet) ) then
      call MessageNotify('W', subname, &
        & 'Rank of data (%c) is "%d", rank of argument is "%d"', &
        & i = (/rank, <%=num%>/), c1 = trim(url) )
    end if
    stat = GT_ERANKMISMATCH
    cause_c = 'array'
    goto 999
  end if
  ! 入力ファイル中のデータの配列形状取得
  ! Get shape of data in an input file
%     unless num == 0
%       (1..num).each do |n|
  call Inquire( var = var , dimord = <%=n%>, &   ! (in)
    & allcount = allcount, err = inq_err )       ! (out)
  if ( .not. inq_err ) then
    data_shape(<%=n%>) = allcount
  else
    data_shape(<%=n%>) = 1
  end if
%       end
  ! 引数の配列形状整形
  ! Arrange shape of an argument
  !
  array_shape_check = array_shape
  sd = 1
  do i = 1, <%=num%> - 1
    if ( array_shape_check(sd) == 1 ) then
      array_shape_check(sd:<%=num%>) = cshift( array_shape_check(sd:<%=num%>), 1, 1 )
    else
      sd = sd + 1
    end if
  end do
  ! 配列形状の比較
  ! Compare shapes
  !
  if ( .not. all( array_shape_check == data_shape ) ) then
    if ( .not. present_and_true(quiet) ) then
      call MessageNotify('W', subname, &
        & 'Shape of data (%c) is (%c), shape of argument is (%c)', &
        & c1 = trim( url ), &
        & c2 = trim( toChar( data_shape(1:rank) ) ), &
        & c3 = trim( toChar( array_shape_check(1:rank) ) ) )
    end if
    stat = GT_EARGSIZEMISMATCH
    cause_c = 'array'
    goto 999
  end if
%     end

  !-------------------------------------
  !  データ取得
  !  Get data
  call Inquire( var = var, & ! (in)
    & size = domain )        ! (out)
%     unless num == 0
  if ( allocated( array_tmp ) ) deallocate( array_tmp )
  allocate( array_tmp(array_allsize) )
  call Get( var, array_tmp, domain )
  array = reshape( array_tmp, array_shape )
  deallocate( array_tmp )
%     else
  call Get( var = var, & ! (inout)
    & nvalue = domain, & ! (in)
    & value = array_tmp) ! (out)
  array = array_tmp(1)
%     end
  call Close( var )
  !-------------------------------------
  !  データファイル名と切り出し範囲の印字
  !  Print data filename and clipping range
  call actual_iorange_dump(url, &  ! (in)
    & actual_url, returned_time, & ! (out) optional
    & time_name = tname, &         ! (in)  optional
    & err = err)                   ! (out) optional
  if ( .not. present_and_true(quiet) ) then
    call MessageNotify('M', subname, 'Input %c', c1=trim(actual_url), rank_mpi = -1)
  end if

999 continue
  call StoreError(stat, subname, err, cause_c)
end subroutine HistoryGet<%=type%><%=num%>

%   end
% end

% ["Double", "Real", "Int"].each do |type|
%   (0..7).each do |num|
%     array = Array.new(num, ':')
%     str = Array.new
subroutine HistoryGet<%=type%><%=num%>Pointer(file, varname, array, range, &
  & quiet, flag_mpi_split, returned_time, flag_time_exist, err)
  use gtdata_types, only: GT_VARIABLE
  use gtdata_generic, only: Open, Inquire, Close, Get
  use dc_string, only: toChar
  use dc_present,only: present_select, present_and_true
  use dc_types, only: STRING, DP<%=', SP' if type == 'Real'%>
  use dc_message, only: MessageNotify
  use dc_trace, only: DbgMessage
#ifdef LIB_MPI
  ! MPI ライブラリ
  ! MPI library
  !
  use mpi
#endif
  implicit none
  character(*), intent(in):: file
  character(*), intent(in):: varname
  character(*), intent(in), optional:: range
  logical, intent(in), optional:: quiet
  logical, intent(in), optional:: flag_mpi_split
  real(DP), intent(out), optional:: returned_time ! データの時刻
  logical, intent(out), optional:: flag_time_exist
  logical, intent(out), optional:: err
  integer:: domain
%     case type when 'Double'
  real(DP), pointer :: array<%="(#{array.join(',')})" unless num == 0%> ! (out)
  real(DP), target :: array_tmp(1)
%    when 'Real'
  real(SP), pointer :: array<%="(#{array.join(',')})" unless num == 0%> ! (out)
  real(SP), target :: array_tmp(1)
%    when 'Int'
  integer,  pointer :: array<%="(#{array.join(',')})" unless num == 0%> ! (out)
  integer,  target :: array_tmp(1)
%    end
  type(GT_VARIABLE):: var
  character(STRING):: file_work, url, actual_url
  character(STRING):: tname
  character(*), parameter :: subname = "HistoryGet<%=type%><%=num%>Pointer"
  interface
    subroutine lookup_growable_url(file, varname, url, range, flag_time_exist, time_name, err)
      character(*), intent(in):: file
      character(*), intent(in):: varname
      character(*), intent(out):: url
      character(*), intent(in), optional:: range
      logical, intent(out), optional:: flag_time_exist
      character(*), intent(out), optional:: time_name
      logical, intent(out), optional:: err
    end subroutine lookup_growable_url
  end interface
  interface
    subroutine actual_iorange_dump(url, actual_url, returned_time, time_name, err)
      use dc_types, only: DP
      character(*), intent(in) :: url                ! 変数 URL
      character(*), intent(out), optional :: actual_url
      ! 正確な入出力範囲指定
      real(DP), intent(out), optional:: returned_time    ! データの時刻
      character(*), intent(in), optional:: time_name ! 時刻次元の名称
      logical, intent(out), optional :: err          ! エラーのフラグ
    end subroutine actual_iorange_dump
  end interface
  interface
    function file_rename_mpi( file ) result(result)
      use dc_types, only: STRING
      character(*), intent(in):: file
      character(STRING):: result
    end function file_rename_mpi
  end interface
  continue
  file_work = file

  ! ファイル名の変更 (MPI 用)
  ! Change filename (for MPI)
  !
  if ( present_and_true( flag_mpi_split ) ) &
    & file_work = file_rename_mpi( file_work )
  ! 必要な情報を gtool 変数化
  !
  call lookup_growable_url(file_work, varname, url, range, &
    & flag_time_exist = flag_time_exist, time_name = tname, err = err)
%   if num == 0
  allocate(array)
%   end
  call DbgMessage('@ url =%c', c1=trim(url))
  ! いよいよデータ取得
  !
  call Open(var, url, err)
%   if num == 0
  call Inquire(var=var, size=domain)
  call Get(var, array_tmp, domain, err)
  array = array_tmp(1)
%   else
  call Get(var, array, err)
%   end
  call Close(var, err)
  call actual_iorange_dump(url, &  ! (in)
    & actual_url, returned_time, & ! (out) optional
    & time_name = tname, &         ! (in)  optional
    & err = err)                   ! (out) optional
  if ( .not. present_and_true(quiet) ) then
    call MessageNotify('M', subname, 'Input %c', c1=trim(actual_url))
  end if
end subroutine HistoryGet<%=type%><%=num%>Pointer

%   end
% end

% ["R", "D", "I"].each do |time|
%   ["Double", "Real", "Int"].each do |type|
%     ['', "Pointer"].each do |ptr|
%       (0..7).each do |num|
%       array = Array.new(num, ':')
subroutine HistoryGet<%=type%><%=num%><%=ptr%>Time<%=time%>( &
  & file, varname, array, time, &
  & quiet, flag_mpi_split, returned_time, flag_time_exist, err)
  use dc_string, only: toChar, Split
  use dc_types, only: STRING, DP<%=', SP' if (type == 'Real' || time == 'R' )%>
  use dc_trace, only: DbgMessage
  use dc_url, only: Url_Chop_IOrange, GT_EQUAL
  use dc_present, only: present_and_true
#ifdef LIB_MPI
  ! MPI ライブラリ
  ! MPI library
  !
  use mpi
#endif
  implicit none
  character(*), intent(in):: file, varname
%     case time when "D"
  real(DP), intent(in):: time
%     when "R"
  real(SP), intent(in):: time
%     when "I"
  integer,  intent(in):: time
%     end
  logical, intent(in), optional:: quiet
%     case type when 'Double'
  real(DP), <%= ptr == 'Pointer' ? 'pointer' : 'intent(out)' %> :: array<%="(#{array.join(',')})" unless num==0%>
%     when 'Real'
  real(SP), <%= ptr == 'Pointer' ? 'pointer' : 'intent(out)' %> :: array<%="(#{array.join(',')})" unless num==0%>
%     when 'Int'
  integer, <%= ptr == 'Pointer' ? 'pointer' : 'intent(out)' %>  :: array<%="(#{array.join(',')})" unless num==0%>
%     end
  logical, intent(in), optional:: flag_mpi_split
  real(DP), intent(out), optional:: returned_time
  logical, intent(out), optional:: flag_time_exist
  logical, intent(out), optional:: err
  character(STRING):: file_work, url, iorange, remainder, timevar_name, time_range
  character(STRING), pointer:: carray (:)
  character(STRING):: tname
  character(*), parameter :: subname = "HistoryGet<%=type%><%=num%>Time<%=time%>"
  interface
    subroutine HistoryGet<%=type%><%=num%><%=ptr%>(&
      & file, varname, array, range, quiet, &
      & flag_mpi_split, returned_time, flag_time_exist, err)
      use dc_types, only: DP<%=', SP' if type == 'Real'%>
      character(*), intent(in):: file
      character(*), intent(in):: varname
      character(*), intent(in), optional:: range
      logical, intent(in), optional:: quiet
      logical, intent(in), optional:: flag_mpi_split
      real(DP), intent(out), optional:: returned_time
      logical, intent(out), optional:: flag_time_exist
      logical, intent(out), optional:: err
%     case type when 'Double'
      real(DP), <%= ptr == 'Pointer' ? 'pointer' : 'intent(out)' %> :: array<%="(#{array.join(',')})" unless num==0%>
%     when 'Real'
      real(SP), <%= ptr == 'Pointer' ? 'pointer' : 'intent(out)' %> :: array<%="(#{array.join(',')})" unless num==0%>
%     when 'Int'
      integer, <%= ptr == 'Pointer' ? 'pointer' : 'intent(out)' %>  :: array<%="(#{array.join(',')})" unless num==0%>
%     end
    end subroutine HistoryGet<%=type%><%=num%><%=ptr%>
  end interface
  interface
    subroutine lookup_growable_url(file, varname, url, range, flag_time_exist, time_name, err)
      character(*), intent(in):: file
      character(*), intent(in):: varname
      character(*), intent(out):: url
      character(*), intent(in), optional:: range
      logical, intent(out), optional:: flag_time_exist
      character(*), intent(out), optional:: time_name
      logical, intent(out), optional:: err
    end subroutine lookup_growable_url
  end interface
  interface
    function file_rename_mpi( file ) result(result)
      use dc_types, only: STRING
      character(*), intent(in):: file
      character(STRING):: result
    end function file_rename_mpi
  end interface
  continue
  file_work = file
  if ( present_and_true( flag_mpi_split ) ) &
    & file_work = file_rename_mpi( file_work )
  call lookup_growable_url(file = file_work, varname = varname, &
    & url = url, &
    & flag_time_exist = flag_time_exist, time_name = tname, err = err)
  call Url_Chop_IOrange( &
    & fullname = url, iorange = iorange, remainder = remainder )
  call Split( str = iorange, carray = carray, sep = GT_EQUAL )
  timevar_name = carray(1)
  deallocate( carray )
  time_range = trim(timevar_name) // GT_EQUAL // trim(toChar(time))
  call HistoryGet<%=type%><%=num%><%=ptr%>( file = file, &
    & varname = varname, array = array, &
    & range = time_range, quiet = quiet, &
    & flag_mpi_split = flag_mpi_split, &
    & returned_time = returned_time, &
    & flag_time_exist = flag_time_exist, &
    & err = err )
end subroutine HistoryGet<%=type%><%=num%><%=ptr%>Time<%=time%>

%       end
%     end
%   end
% end

subroutine lookup_growable_url( &
  & file, varname, & ! (in)
  & url, &           ! (out)
  & range, &         ! (in) optional
  & flag_time_exist, time_name, err) ! (out) optional
  !
  ! file の変数 varname が依存する次元の内, 時間の次元
  ! (growable == .TRUE. のもの, つまり無制限次元) の変数名,
  ! およびその最後の値を取得し, gtool 変数化
  ! ("file@varname,time=10.5" みたいな) して返す.
  !
  ! * もしも varname が次元変数である場合は「time=」を付けずに返す.
  ! * range を与えた場合, 以下のチェックを行った後, それを gtool4
  !   変数の iorange 部分に付加する.
  !   * range に空文字が与えられた場合, range が与えられない場合と
  !     同じ動作をする.
  !   * range 内に時間次元が設定されていない場合は, 自動的に
  !     時間次元に関する iorange ("time=0.5") が指定される.
  ! * 数値のみの文字列 (例: "20", "10.354") が与えられる場合,
  !   エラーを生じる.
  !
  ! *flag_time_exist* が与えられる場合には, 得られるデータに
  ! 時刻次元が含まれる場合には .true. を, 含まれない場合は
  ! .false. を返す.
  ! *time_name* が与えられる場合には, 得られるデータに
  ! 時刻次元が含まれる場合にはその時刻次元変数名を,
  ! 含まれない場合には空文字を返す.
  !
  use gtdata_types, only: GT_VARIABLE
  use gtdata_generic, only: Open, Close, Inquire
  use dc_present,only: present_select, present_and_not_empty, present_and_true
  use dc_string, only: toChar
  use dc_error,  only: StoreError, DC_NOERR, GT_ENOUNLIMITDIM, &
    & NF90_EINVAL, GT_ENOTVAR, GT_EBADGT4COMMAGRAPHY
  use dc_url, only: GT_CIRCUMFLEX, GT_COMMA, GT_EQUAL
  use dc_url, only: UrlSplit, UrlMerge, UrlSearchIORange
  use dc_regex, only: match
  use dc_types, only: DP, STRING
  use dc_trace, only: Beginsub, Endsub, DbgMessage

  character(*), intent(in) :: file           ! ファイル名
  character(*), intent(in) :: varname        ! 変数名
  character(*), intent(out) :: url           ! gtool変数化した文字列
  character(*), intent(in), optional:: range ! 範囲限定や一点切り出し指定
  logical, intent(out), optional:: flag_time_exist ! 時刻次元の存在の有無
  character(*), intent(out), optional:: time_name  ! 時刻次元の名称
  logical, intent(out), optional :: err      ! エラーのフラグ
  !
  type(GT_VARIABLE)                       :: var
  type(GT_VARIABLE), allocatable          :: dimvar(:)
  character(STRING) :: time_url, tname, time_iorange
  character(STRING) :: iorange, cause_c
  logical:: growable, nounlimited
  integer:: allcount, timecount, nd, i, stat
  integer:: regex_stat, regex_len
  character(*), parameter :: subname = "lookup_growable_url"
continue

  call BeginSub(subname, '<file=%c varname=%c range=%c>', &
    & c1=trim(file), c2=trim(varname), &
    & c3=trim(present_select('', 'no-range', range)))

  stat = DC_NOERR
  cause_c = ""
  url = ""

  ! 引数の正当性をチェック
  if (.not. present_and_not_empty(file)) then
    stat = NF90_EINVAL
    cause_c = '"file" is not specified'
    goto 999
  elseif (.not. present_and_not_empty(varname)) then
    stat = NF90_EINVAL
    cause_c = '"varname" is not specified'
    goto 999
  end if

  ! 時刻次元の変数名, およびその最終時刻の
  ! 探査のために file@varname を open (まだデータを取得しない)
  call Open(var, UrlMerge(file, varname), err = err)
  if ( present_and_true(err) ) then
    stat = GT_ENOTVAR
    goto 999
  end if

  ! 次元の数を取得
  call Inquire(var=var, alldims=nd)
  call DbgMessage('@ alldims = %d', i=(/nd/))
  if (allocated(dimvar)) then
    deallocate(dimvar)
  end if
  allocate(dimvar(nd))
  !
  ! 変数が無制限変数を持たない場合, もしくは変数自体が
  ! 無制限次元変数である場合には, それに関する iorange を
  ! 付けないで返すよう, フラグを立てる.
  ! それ以外は .false. にする.
  nounlimited = .true.
  !
  ! 各次元毎に情報を取得し, growable == .TRUE. のもの (つまりは時間)
  ! の変数名 (tname) を取得する.
  call DbgMessage('[%c: growable-dim-search]', c1=trim(subname))
  tname = ''
  do, i = 1, nd
    call Open(var = dimvar(i), &        ! (out)
      & source_var = var, dimord = i, & ! (in)
      & count_compact = .TRUE., &       ! (in)
      & err = err)                      ! (out) optional
    ! まずは変数入り gtool4 変数を time_url に取得
    call Inquire(var = dimvar(i), &           ! (in)
      & growable = growable, &                ! (out)
      & allcount = allcount, url = time_url)  ! (out)
    call DbgMessage('  [dim=<%d>: growable=<%y>: url=<%c>]', &
      &  i = (/i/), L = (/growable/), c1 = trim(time_url))

    ! 変数部分だけ分離
    call UrlSplit( fullname = time_url, & ! (in)
      &            var = tname)           ! (out)

    ! 無制限次元で, かつ開こうとする変数自体が無制限次元でない場合
    !
    if ( growable .and. trim(tname) /= trim(varname) ) then

      ! 総数 = 最後の数を timecount に
      !
      timecount = allcount
      nounlimited = .false.
    endif
    call Close(dimvar(i))

    ! 時刻次元が見つかった場合にはループを抜ける
    !
    if ( .not. nounlimited ) then
      exit

    ! 時刻次元ではない場合, tname を空に
    !
    else
      tname = ''
    end if

  end do
  ! 探査を終了したので閉じる
  call Close(var)
  if (stat /= DC_NOERR) then
    goto 999
  end if

  ! 時刻次元名を返す
  !
  if ( present(time_name) ) time_name = tname

  ! 時刻部分の iorange を作成しておく.
  ! 格子点情報で取得されているので, 頭に "^" を付加する.
  if (nounlimited) then
    time_iorange = ''
    if ( present(flag_time_exist) ) flag_time_exist = .false.
!!$    if ( present(returned_time) ) returned_time = 0.
  else
    time_iorange = trim(tname) // GT_EQUAL // &
      & GT_CIRCUMFLEX // adjustl(toChar(timecount))
    if ( present(flag_time_exist) ) flag_time_exist = .true.
!!$    if ( present(returned_time) ) then
!!$      returned_time =
!!$    end if
  end if

  ! iorange を指定する.
  ! 時刻に関しては, range が存在しない場合には
  ! 自動取得した最後の時刻を付加する.
  ! range が存在する場合, "=" が含まれなければ, gtool4 のコンマ記法
  ! として不適切としてエラーを生じる.
  ! "=" が含まれる場合, iorange としてそのまま iorange になる.
  ! ただし, その iorange に時刻次元が含まれない場合,
  ! やはり先ほど自動取得した値が付加される.
  ! 当然, 時刻次元が存在しない場合には付加しない.
  if (.not. present_and_not_empty(range)) then
    iorange = time_iorange
  else
    ! range がコンマ記法になっているか, "=" があるかどうかで調べる
    call match(GT_EQUAL, range, regex_len, regex_stat)
    ! コンマ記法になってない場合は無制限次元の値と判定
    if (regex_stat < 0) then
      cause_c = range
      stat = GT_EBADGT4COMMAGRAPHY
      goto 999
!!$      iorange = trim(tname) // GT_EQUAL // adjustl(range)
    else
      ! コンマ記法になっている場合, まずその中に無制限次元が
      ! 存在しているか調べ, 存在してない場合のみ time_iorange を
      ! 付加する.
      if (trim(UrlSearchIORange(range, tname)) /= "") then
        iorange = range
      else
        if (trim(time_iorange) /= "") then
          iorange = range // GT_COMMA // time_iorange
        else
          iorange = range
        end if
      end if
    end if
  endif
  call DbgMessage('@ iorange=%c', c1=trim(iorange))

  ! file, varname, iorange を gtool変数化
  ! (「file@varname,time=10.5」のように)
  url = UrlMerge(file, varname, '', iorange)

999 continue
  call StoreError(stat, subname, err, cause_c)
  call EndSub(subname, '<url=%c>', c1=trim(url))
end subroutine lookup_growable_url

subroutine actual_iorange_dump( url, & ! (in)
  & actual_url, returned_time, &  ! (out) optional
  & time_name, &                  ! (in)  optional
  & err )                         ! (out) optional
  !
  ! 変数 URL *url* に対応するファイル, 変数からデータを取り出す際,
  ! 入出力範囲指定によって切り出される値の本当の位置を
  ! 標準出力に出力する. *actual_url* が与えられる場合には
  ! その引数に値を返し, 標準出力には出力しない.
  !
  ! HistoryGet, HistoryGetPointer が下層で呼び出している
  ! gtdata_generic#Get は, 入出力範囲が次元データに正確に一致しない
  ! 場合, 最も近い値を自動的に選択して切り出す. しかしその結果,
  ! 「本当はどこのデータを入力したか」がわからない場合があるため,
  ! このサブルーチンによって正確な位置をユーザに知らせる.
  !
  ! *time_name* と *returned_time* が与えられる場合には,
  ! *returned_time* に時刻の数値を返す.
  ! *returned_time* のみ与えられる場合には 0 を返す.
  !
  use dc_types, only: DP, STRING
  use dc_string, only: Split, JoinChar, toChar, RoundNum
  use dc_url, only: UrlSearchIORange, UrlMerge, UrlSplit
  use dc_url, only: GT_COMMA, GT_EQUAL, GT_COLON
  use dc_message, only: MessageNotify
  use dc_trace, only: DbgMessage
  use dc_regex, only: match
  use gtdata_types, only: GT_VARIABLE
  use gtdata_generic, only: Open, Close, Get
  use dc_error,  only: StoreError, DC_NOERR

  character(*), intent(in):: url            ! 変数 URL
  character(*), intent(out), optional:: actual_url
                                             ! 正確な入出力範囲指定に修正
                                             ! された変数 URL
  real(DP), intent(out), optional:: returned_time ! データの時刻
  character(*), intent(in), optional:: time_name  ! 時刻次元の名称
  logical, intent(out), optional:: err      ! エラーのフラグ

  character(STRING), pointer :: iorange_each(:) =>null()
  character(STRING), pointer :: range_values(:) =>null()
  character(STRING), pointer :: new_iorange_each(:) =>null()
  character(STRING), pointer :: new_range_values(:) =>null()
  character(STRING):: new_url, new_iorange, url_tmp, dimname
  character(STRING):: file, varname, range, cause_c
  type(GT_VARIABLE):: var
  real :: iorange_value(1)
  integer :: i, j, regex_len, regex_stat, stat

  character(*), parameter :: subname = "actual_iorange_dump"

  continue

  new_iorange = ''
  cause_c = ''
  stat = DC_NOERR

  if ( present(returned_time) ) then
    returned_time = 0.
  end if


  call UrlSplit(url, file, varname, iorange=range)
  call Split(range, iorange_each, GT_COMMA)

  allocate(new_iorange_each(size(iorange_each)))
  do i = 1, size(iorange_each)
    call match(GT_EQUAL, iorange_each(i), regex_len, regex_stat)
    if (regex_stat < 0 .or. regex_len < 2) then
      new_iorange_each(i) = trim(iorange_each(i))
    else
      dimname = iorange_each(i)(:regex_len-1)
      call Split(iorange_each(i)(regex_len+1:), range_values, GT_COLON)
      allocate(new_range_values(size(range_values)))

      do j = 1, size(range_values)
        url_tmp = UrlMerge(file, dimname, '', &
          & iorange=trim(dimname) // GT_EQUAL // trim(range_values(j)))
        call Open(var, url_tmp)
        call Get(var, iorange_value, 1)
        call Close(var)
        if ( present(time_name) .and. present(returned_time) ) then
          if ( trim(time_name) == trim(dimname) ) then
            returned_time = iorange_value(1)

          end if
        end if
        new_range_values(j) = RoundNum( toChar(iorange_value) )
      end do
      new_iorange_each(i) = &
        & trim(dimname) // GT_EQUAL // JoinChar(new_range_values, GT_COLON)

      deallocate(new_range_values)
      deallocate(range_values)

    end if
  end do

  new_iorange = JoinChar(new_iorange_each, GT_COMMA)
  deallocate(new_iorange_each)
  deallocate(iorange_each)

  new_url = UrlMerge(file, varname, '', new_iorange)

  if (present(actual_url)) then
    actual_url = new_url
  else
    call MessageNotify('M', subname, 'Input %c', c1=trim(new_url))
  end if

999 continue
  call StoreError(stat, subname, err, cause_c)
end subroutine actual_iorange_dump



function file_rename_mpi( file ) result(result)
  use dc_types, only: STRING, TOKEN
  use dc_string, only: CPrintf, LChar
#ifdef LIB_MPI
  ! MPI ライブラリ
  ! MPI library
  !
  use mpi
#endif
  implicit none
  character(*), intent(in):: file
  character(STRING):: result
#ifdef LIB_MPI
  logical:: initflag_mpi
  character(STRING):: file_mpi
  character(TOKEN):: nc_suffix_mpi
  integer:: myrank_mpi, err_mpi, index_nc_mpi
  character(TOKEN), save:: save_myrank = ''
  character(*), parameter:: rank_prefix = '_rank'
#endif
  continue
#ifndef LIB_MPI
  result = file
  return
#else
  if ( trim(save_myrank) == '' ) then
    call MPI_Initialized(initflag_mpi, err_mpi)
    if ( initflag_mpi ) then
      call MPI_Comm_Rank(MPI_COMM_WORLD, myrank_mpi, err_mpi)
      save_myrank = CPrintf( '%06d', i = (/ myrank_mpi /) )
    else
      result = file
      return
    end if
  end if
  file_mpi = file
  index_nc_mpi = index( LChar(file), '.nc' )
  if ( index_nc_mpi > 1 ) then
    nc_suffix_mpi = file_mpi(index_nc_mpi:)
    file_mpi = file_mpi(:index_nc_mpi-1) // &
      & rank_prefix // trim( save_myrank ) // trim( nc_suffix_mpi )
  elseif ( index_nc_mpi > 0 ) then
    file_mpi = rank_prefix // trim( save_myrank ) // trim( file_mpi )
  else
    file_mpi = trim( file_mpi ) // rank_prefix // trim( save_myrank )
  end if
  result = file_mpi
#endif
end function file_rename_mpi
